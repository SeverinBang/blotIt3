rbind,
lapply(
seq_len(nrow(parameter_table)),
function (i) {
out <- parameter_table[i,]
out$lower <- ci$lower[
which(ci$value == parameter_table[i,]$value)
]
out$upper <- ci$upper[
which(ci$value == parameter_table[i,]$value)
]
return(out)
}
)
)
} else {
# Calculating the error from the inverse of the Fisher information
# matrix which is in this case the Hessian, to which the above
# calculated Bessel correction is applied.
parameter_table$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
) * bessel
parameter_table$lower <- parameter_table$value - parameter_table$sigma
parameter_table$upper <- parameter_table$value + parameter_table$sigma
}
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
parameter_table$value <- exp(parameter_table$value)
parameter_table$sigma <- parameter_table$value * parameter_table$sigma
parameter_table$lower <- parameter_table$value * parameter_table$lower
parameter_table$upper <- parameter_table$value * parameter_table$upper
}
parameter_fit_scale_log
parameter_table
parameter_table[,1]
parameter_table[1,]
parameter_table[1,]$lower
parameter_table[1,]$value - parameter_table[1,]$sigma
parameter_table <- data.frame(
name = current_name,
level = c(
rep(levels_list[[1]], length(effects_pars[[1]])),
rep(levels_list[[2]], length(effects_pars[[2]])),
rep(levels_list[[3]], length(effects_pars[[3]]))
),
parameter = names(fit_result$argument),
value = fit_result$argument,
nll = fit_result$value,
no_pars = length(fit_result$argument) - normalize,
no_data = nrow(data_fit)
)
parameter_table$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
) * bessel
parameter_table$lower <- parameter_table$value - parameter_table$sigma
parameter_table$upper <- parameter_table$value + parameter_table$sigma
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
parameter_table$value <- exp(parameter_table$value)
parameter_table$sigma <- parameter_table$value * parameter_table$sigma
parameter_table$lower <- parameter_table$value * parameter_table$lower
parameter_table$upper <- parameter_table$value * parameter_table$upper
}
parameter_table[1,]$lower
parameter_table[1,]$value - parameter_table[1,]$sigma
parameter_table
parameter_table <- data.frame(
name = current_name,
level = c(
rep(levels_list[[1]], length(effects_pars[[1]])),
rep(levels_list[[2]], length(effects_pars[[2]])),
rep(levels_list[[3]], length(effects_pars[[3]]))
),
parameter = names(fit_result$argument),
value = fit_result$argument,
nll = fit_result$value,
no_pars = length(fit_result$argument) - normalize,
no_data = nrow(data_fit)
)
if (ci_profiles == TRUE) {
parameter_table$sigma <-  NA
parameter_table <- do.call(
rbind,
lapply(
seq_len(nrow(parameter_table)),
function (i) {
out <- parameter_table[i,]
out$lower <- ci$lower[
which(ci$value == parameter_table[i,]$value)
]
out$upper <- ci$upper[
which(ci$value == parameter_table[i,]$value)
]
return(out)
}
)
)
} else {
# Calculating the error from the inverse of the Fisher information
# matrix which is in this case the Hessian, to which the above
# calculated Bessel correction is applied.
parameter_table$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
) * bessel
#
#         parameter_table$lower <- parameter_table$value - parameter_table$sigma
#         parameter_table$upper <- parameter_table$value + parameter_table$sigma
}
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
parameter_table$value <- exp(parameter_table$value)
parameter_table$sigma <- parameter_table$value * parameter_table$sigma
if (ci_profiles == TRUE) {
parameter_table$lower <- exp(parameter_table$lower)
parameter_table$upper <- exp(parameter_table$upper)
} else {
parameter_table$lower <- parameter_table$value -
parameter_table$sigma
parameter_table$upper <- parameter_table$value +
parameter_table$sigma
}
}
parameter_table
# Calculating the error from the inverse of the Fisher information
# matrix which is in this case the Hessian, to which the above
# calculated Bessel correction is applied.
parameter_table$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
) * bessel
parameter_table$value <- exp(parameter_table$value)
parameter_table$sigma <- parameter_table$value * parameter_table$sigma
arameter_table$lower <- parameter_table$value -
parameter_table$sigma
parameter_table$upper <- parameter_table$value +
parameter_table$lower <- parameter_table$value -
parameter_table$sigma
parameter_table$upper <- parameter_table$value +
parameter_table$sigma
parameter_table
out_aligned
residuals_fit <- resolve_function(
current_parameters = fit_result$argument,
pass_parameter_list = pass_parameter_list,
pass_parameter_list2 = pass_parameter_list2,
calculate_derivative = FALSE
)
bessel <- sqrt(
nrow(data_fit) / (nrow(data_fit) - length(initial_parameters) +
normalize)
)
# Get singular values (roots of non negative eigenvalues of M^* \cdot M)
# here it is synonymous with eigenvalue.
single_values <- svd(fit_result[["hessian"]])[["d"]]
# Define a tollerance threshold, the root of the machine precission is
# a usual value for this threshold.
tol <- sqrt(.Machine$double.eps)
# Define nonidentifiable as being "to small to handle", judged by the
# above defined threshold
non_identifiable <- which(single_values < tol * single_values[1])
if (length(non_identifiable) > 0) {
warning("Eigenvalue(s) of Hessian below tolerance. Parameter
uncertainties might be underestimated.")
}
parameter_table <- data.frame(
name = current_name,
level = c(
rep(levels_list[[1]], length(effects_pars[[1]])),
rep(levels_list[[2]], length(effects_pars[[2]])),
rep(levels_list[[3]], length(effects_pars[[3]]))
),
parameter = names(fit_result$argument),
value = fit_result$argument,
nll = fit_result$value,
no_pars = length(fit_result$argument) - normalize,
no_data = nrow(data_fit)
)
if (ci_profiles == TRUE) {
parameter_table$sigma <-  NA
parameter_table <- do.call(
rbind,
lapply(
seq_len(nrow(parameter_table)),
function (i) {
out <- parameter_table[i,]
out$lower <- ci$lower[
which(ci$value == parameter_table[i,]$value)
]
out$upper <- ci$upper[
which(ci$value == parameter_table[i,]$value)
]
return(out)
}
)
)
} else {
# Calculating the error from the inverse of the Fisher information
# matrix which is in this case the Hessian, to which the above
# calculated Bessel correction is applied.
parameter_table$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
) * bessel
#
#         parameter_table$lower <- parameter_table$value - parameter_table$sigma
#         parameter_table$upper <- parameter_table$value + parameter_table$sigma
}
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
parameter_table$value <- exp(parameter_table$value)
parameter_table$sigma <- parameter_table$value * parameter_table$sigma
if (ci_profiles == TRUE) {
parameter_table$lower <- exp(parameter_table$lower)
parameter_table$upper <- exp(parameter_table$upper)
} else {
parameter_table$lower <- parameter_table$value -
parameter_table$sigma
parameter_table$upper <- parameter_table$value +
parameter_table$sigma
}
}
if (verbose) {
cat("Estimated parameters on non-log scale:\n")
print(parameter_table)
cat(
"converged:", fit_result$converged, ", iterations:",
fit_result$iterations, "\n"
)
cat("-2*LL: ", fit_result$value, "on", nrow(current_data) +
normalize - length(fit_result$argument), "degrees of freedom\n")
}
attr(parameter_table, "value") <- fit_result$value
attr(parameter_table, "df") <- nrow(current_data) + normalize -
length(fit_result$argument)
# * out_prediction --------------------------------------------------------
# Predicted data
out_prediction <- current_data
out_prediction$sigma <- fit_result$sigma * bessel
out_prediction$value <- fit_result$prediction
# * out_scaled ------------------------------------------------------------
# Initialize list for scaled values
initial_values_scaled <- rep(0, nrow(current_data))
if (verbose) {
cat("Inverting model ... ")
}
values_scaled <- try(
# my_multiroot
rootSolve::multiroot(
f = evaluate_model,
start = initial_values_scaled,
jacfunc = evaluate_model_jacobian,
par_list = residuals_fit[-1],
verbose = FALSE,
pass_parameter_list = pass_parameter_list,
pass_parameter_list2 = pass_parameter_list2
)$root,
silent = TRUE
)
if (verbose) {
cat("done\n")
}
if (inherits(values_scaled, "try-error")) {
out_scaled <- NULL
warning("Rescaling to common scale not possible.
Equations not invertible.")
} else {
my_deriv <- abs(
evaluate_model_jacobian(
values_scaled,
residuals_fit[-1],
pass_parameter_list = pass_parameter_list,
pass_parameter_list2 = pass_parameter_list2
)
)
sigmas_scaled <- fit_result$sigma * bessel / my_deriv
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
values_scaled <- exp(values_scaled)
sigmas_scaled <- values_scaled * sigmas_scaled
}
upper_scaled <- values_scaled + sigmas_scaled
lower_scaled <- values_scaled - sigmas_scaled
# scaling_list_scaled <- scale_values(
#     parameter_fit_scale_log = parameter_fit_scale_log,
#     output_scale = output_scale,
#     value = values_scaled,
#     upper = upper_scaled,
#     lower = lower_scaled,
#     sigma = sigmas_scaled
# )
#
# out_scaled <- current_data
# out_scaled$value <- scaling_list_scaled$value
# out_scaled$sigma <- scaling_list_scaled$sigma
# out_scaled$upper <- scaling_list_scaled$upper
# out_scaled$lower <- scaling_list_scaled$lower
# the following is ONLY needed when the scaling_list_scaled part is off.
out_scaled <- current_data
out_scaled$value <- values_scaled
out_scaled$sigma <- sigmas_scaled
out_scaled$upper <- upper_scaled
out_scaled$lower <- lower_scaled
}
# * out_aligned -----------------------------------------------------------
no_initial <- length(levels_list[[1]])
# Use one datapoint per unique set of fixed parameters
out_aligned <- current_data[
!duplicated(data_fit$distinguish),
intersect(effects_values[[1]], colnames(current_data))
]
out_aligned
# The values are the fitted parameters for the respective fixed
# parameter ensembles.
out_aligned$value <- residuals_fit[[effects_pars[[1]][1]]]
out_aligned
# The values are the fitted parameters for the respective fixed
# parameter ensembles.
out_aligned$value <- residuals_fit[[effects_pars[[1]][1]]]
# The sigmas are calculated by evaluating the fisher information matrix
out_aligned$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
)[seq_len(no_initial)] * bessel
out_aligned
ci_profiles
parameter_table
tkkk <- do.call(
rbind,
lapply(
seq_len(nrow(out_aligned)),
function (i) {
out <- out_aligned[i,]
out$lower <- ci$lower[
which(ci$value == out_aligned[i,]$value)
]
out$upper <- ci$upper[
which(ci$value == out_aligned[i,]$value)
]
out$value_test <- ci$value[
which(ci$value == out_aligned[i,]$value)
]
return(out)
}
)
)
tkkk
# Use one datapoint per unique set of fixed parameters
out_aligned <- current_data[
!duplicated(data_fit$distinguish),
intersect(effects_values[[1]], colnames(current_data))
]
# The values are the fitted parameters for the respective fixed
# parameter ensembles.
out_aligned$value <- residuals_fit[[effects_pars[[1]][1]]]
if (ci_profiles == TRUE) {
out_aligned$sigma <-  NA
out_aligned <- do.call(
rbind,
lapply(
seq_len(nrow(out_aligned)),
function (i) {
out <- out_aligned[i,]
out$lower <- ci$lower[
which(ci$value == out_aligned[i,]$value)
]
out$upper <- ci$upper[
which(ci$value == out_aligned[i,]$value)
]
return(out)
}
)
)
} else {
# The sigmas are calculated by evaluating the fisher information matrix
out_aligned$sigma <- as.numeric(
sqrt(diag(2 * MASS::ginv(fit_result$hessian)))
)[seq_len(no_initial)] * bessel
}
out_aligned
# transform parameters back if fitted on log scale
if (parameter_fit_scale_log == TRUE) {
out_aligned$value <- exp(out_aligned$value)
out_aligned$sigma <- out_aligned$value * out_aligned$sigma
if (ci_profiles == TRUE) {
out_aligned$lower <- exp(out_aligned$lower)
out_aligned$upper <- exp(out_aligned$upper)
} else {
out_aligned$lower <- out_aligned$value -
out_aligned$sigma
out_aligned$upper <- out_aligned$value +
out_aligned$sigma
}
}
out_aligned
library(blotIt3)
library(blotIt3)
library(blotIt3)
library(tidyverse)
library(blotIt3)
library(blotIt3)
library(tidyverse)
library(blotIt3)
# * my sample data --------------------------------------------------------
if (F) {
real_data3 <- read_wide(
file = paste0(
"./tests/my_test/example_test.csv"
),
description = 1:3,
sep = ",",
dec = "."
)
selected_data <- subset(
real_data3,
name %in%  c("target_A", "target_B", "target_C") & condition == "condition_A"
)
# real_data3 <- real_data3[c(1, 2, 7, 8, 9)]
# real_data3 <- subset(real_data3, name == "pEPOR_au")
# names(real_data3) <- c("time", "condition", "ID", "name", "value")
blotIt_test3 <- align_me(
data = selected_data, # real_data3,
model = "yi / sj",
error_model = "value * sigmaR",
distinguish = yi ~ name + time + condition,
scaling = sj ~ name + ID,
error = sigmaR ~ name + 1,
parameter_fit_scale_log = TRUE,
normalize = TRUE,
average_techn_rep = FALSE,
verbose = FALSE,
normalize_input = TRUE,
output_scale = "linear"
)
}
imported <- read_csv("/home/severin/Documents/PhD/Paper/2020-04-09_blotIt2/git/BlotItPaper/03-DataDanielK/Daten_Angela_170522/Summary_all_targets_May_2017.csv")
blotIt_test3 <- align_me(
data = imported, # real_data3,
model = "yi / sj",
error_model = "value * sigmaR",
distinguish = yi ~ name + time + condition,
scaling = sj ~ name + gel + sample,
error = sigmaR ~ name + 1,
parameter_fit_scale_log = TRUE,
normalize = TRUE,
average_techn_rep = FALSE,
verbose = FALSE,
normalize_input = TRUE,
output_scale = "linear"
)
library(blotIt3)
library(blotIt3)
# * my sample data --------------------------------------------------------
if (F) {
real_data3 <- read_wide(
file = paste0(
"./tests/my_test/example_test.csv"
),
description = 1:3,
sep = ",",
dec = "."
)
selected_data <- subset(
real_data3,
name %in%  c("target_A", "target_B", "target_C") & condition == "condition_A"
)
# real_data3 <- real_data3[c(1, 2, 7, 8, 9)]
# real_data3 <- subset(real_data3, name == "pEPOR_au")
# names(real_data3) <- c("time", "condition", "ID", "name", "value")
blotIt_test3 <- align_me(
data = selected_data, # real_data3,
model = "yi / sj",
error_model = "value * sigmaR",
distinguish = yi ~ name + time + condition,
scaling = sj ~ name + ID,
error = sigmaR ~ name + 1,
parameter_fit_scale_log = TRUE,
normalize = TRUE,
average_techn_rep = FALSE,
verbose = FALSE,
normalize_input = TRUE,
output_scale = "linear"
)
}
imported <- read_csv("/home/severin/Documents/PhD/Paper/2020-04-09_blotIt2/git/BlotItPaper/03-DataDanielK/Daten_Angela_170522/Summary_all_targets_May_2017.csv")
blotIt_test3 <- align_me(
data = imported, # real_data3,
model = "yi / sj",
error_model = "value * sigmaR",
distinguish = yi ~ name + time + condition,
scaling = sj ~ name + gel + sample,
error = sigmaR ~ name + 1,
parameter_fit_scale_log = TRUE,
normalize = TRUE,
average_techn_rep = FALSE,
verbose = FALSE,
normalize_input = TRUE,
output_scale = "linear"
)
blotIt_test3
blotIt_test3 <- align_me(
data = imported, # real_data3,
model = "yi / sj",
error_model = "value * sigmaR",
distinguish = yi ~ name + time + condition,
scaling = sj ~ name + gel + sample,
error = sigmaR ~ name + 1,
parameter_fit_scale_log = TRUE,
normalize = TRUE,
average_techn_rep = FALSE,
verbose = FALSE,
normalize_input = TRUE,
output_scale = "linear",
ci_profiles = TRUE
)
blotIt_test3
